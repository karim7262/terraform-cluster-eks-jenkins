name: 'Terraform'

on:
  schedule:
    - cron: "0 8 * * 1-5"
  push:
    branches:
    - master
  pull_request:

jobs:
  terraform:
    name: 'Terraform'
    runs-on: ubuntu-latest
    environment: production

    # Use the Bash shell regardless whether the Github Actions runner is ubuntu-latest, macos-latest, or windows-latest
    defaults:
      run:
        shell: bash

    steps:

      - name: Checkout tools repo
        uses: actions/checkout@v2
        with:
          repository: nirmata/terraform-provider-nirmata
          path: terraform-provider-nirmata

      - name: Build nirmata provider
        run: |
          # move to folder where nrimata provider was pulled 
          cd terraform-provider-nirmata

          # make a new nirmata terraform provider build
          go build 
          ls -alt

      # Checkout the repository to the GitHub Actions runner.
      - name: Checkout
        uses: actions/checkout@v2

      # Mirror existing terraform provider in host machine
      - name: Mirror 
        run: |
          mkdir ~/terraform-file-mirror
          terraform providers mirror ~/terraform-file-mirror
          cd ~/terraform-file-mirror
          ls -l
          cd registry.terraform.io/nirmata/nirmata
          ls -l

      # Install the latest version of Terraform CLI and configure the Terraform CLI configuration file with a Terraform Cloud user API token
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v1
        with:
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

      # Set the CLI config to a temporary file
      - name: CLI config
        run: 
          export TF_CLI_CONFIG_FILE="$HOME/.teraformrctemp"
          cat <<EOF > $TF_CLI_CONFIG_FILE
          provider_installation {
            filesystem_mirror {
              path = "$HOME/terraform-file-mirror/"
              include = ["nirmata/nirmata"] 
            }
            direct {
              exclude = ["nirmata/nirmata"]
            }
          }
          export TF_LOG=DEBUG
      
      # Initialize a new or existing Terraform working directory by creating initial files, loading any remote state, downloading modules, etc.
      - name: Terraform Init
        run: terraform init

         

    # # Checkout the repository to the GitHub Actions runner.
    #   - name: Checkout
    #     uses: actions/checkout@v2

    #   # Install the latest version of Terraform CLI and configure the Terraform CLI configuration file with a Terraform Cloud user API token
    #   - name: Setup Terraform
    #     uses: hashicorp/setup-terraform@v1
    #     with:
    #       cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

    #   # Initialize a new or existing Terraform working directory by creating initial files, loading any remote state, downloading modules, etc.
    #   - name: Terraform Init
    #     run: terraform init

    #   # Generates an execution plan for Terraform
    #   - name: Terraform Plan
    #     run: terraform plan

    #     # On push to master, build or change infrastructure according to Terraform configuration files.
    #     # Note: It is recommended to set up a required "strict" status check in your repository for "Terraform Cloud". See the documentation on "strict" required status checks for more information: https://help.github.com/en/github/administering-a-repository/types-of-required-status-checks
    #   - name: Terraform Apply
    #     if: github.ref == 'refs/heads/master' && github.event_name == 'push'
    #     run: terraform apply -auto-approve

    #   # - name: Check Cluster State
    #   #   run: |
    #   #     result=$(curl --user automation-admin@nirmata.com:${{ secrets.NIRMATA_PASS }}  https://nirmata.io/cluster/api/KubernetesCluster?fields=name,id | jq -r '.[] | select(.name == "cluster-eks-test-automation01") | .id')
    #   #     echo $result
    #   #     state=$(curl --user automation-admin@nirmata.com:${{ secrets.NIRMATA_PASS }} https://nirmata.io/cluster/api/KubernetesCluster/${result} | jq .state )
    #   #     echo $state
    
    #   - name: Terraform Destroy.
    #     run: terraform destroy -auto-approve
 
